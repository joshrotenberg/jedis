{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"3to4-primitives/","title":"3to4 primitives","text":""},{"location":"3to4-primitives/#the-following-methods-now-return-primitive-values","title":"The following methods now return primitive values:","text":"<p>&gt;&gt; <code>long</code>/<code>boolean</code>/<code>double</code> instead of <code>Long</code>/<code>Boolean</code>/<code>Double</code>:</p> <ul> <li>dbSize()</li> <li>lastsave()</li> <li>slowlogLen()</li> <li>clientId()</li> <li>clientUnblock(long clientId, UnblockType unblockType)</li> <li>clientKill(ClientKillParams params)</li> <li>aclDelUser(String name)</li> <li>aclDelUser(byte[] name)</li> <li>move(String key, int dbIndex)</li> <li>move(byte[] key, int dbIndex)</li> <li>waitReplicas(int replicas, long timeout)</li> <li>waitReplicas(String key, int replicas, long timeout)</li> <li>exists(String key)</li> <li>exists(byte[] key)</li> <li>exists(String... keys)</li> <li>exists(byte[]... keys)</li> <li>persist(String key)</li> <li>expire(String key, long seconds)</li> <li>expire(byte[] key, long seconds)</li> <li>pexpire(String key, long milliseconds)</li> <li>pexpire(byte[] key, long milliseconds)</li> <li>expireAt(String key, long unixTime)</li> <li>expireAt(byte[] key, long unixTime)</li> <li>pexpireAt(String key, long millisecondsTimestamp)</li> <li>pexpireAt(byte[] key, long millisecondsTimestamp)</li> <li>ttl(String key)</li> <li>ttl(byte[] key)</li> <li>pttl(String key)</li> <li>touch(String key)</li> <li>touch(byte[] key)</li> <li>touch(String... keys)</li> <li>touch(byte[]... keys)</li> <li>setbit(String key, long offset, boolean value)</li> <li>setbit(byte[] key, long offset, boolean value)</li> <li>getbit(String key, long offset)</li> <li>getbit(byte[] key, long offset)</li> <li>setrange(String key, long offset, String value)</li> <li>setrange(byte[] key, long offset, byte[] value)</li> <li>setnx(String key, String value)</li> <li>setnx(byte[] key, byte[] value)</li> <li>incr(String key)</li> <li>incr(byte[] key)</li> <li>decr(String key)</li> <li>decr(byte[] key)</li> <li>incrBy(String key, long increment)</li> <li>incrBy(byte[] key, long increment)</li> <li>decrBy(String key, long decrement)</li> <li>decrBy(byte[] key, long decrement)</li> <li>incrByFloat(String key, double increment)</li> <li>incrByFloat(byte[] key, double increment)</li> <li>append(String key, String value)</li> <li>append(byte[] key, byte[] value)</li> <li>hset(String key, String field, String value)</li> <li>hset(byte[] key, byte[] field, byte[] value)</li> <li>hset(String key, Map hash) <li>hset(byte[] key, Map hash) <li>hsetnx(String key, String field, String value)</li> <li>hsetnx(byte[] key, byte[] field, byte[] value)</li> <li>hincrBy(String key, String field, long value)</li> <li>hincrBy(byte[] key, byte[] field, long value)</li> <li>hincrByFloat(String key, String field, double value)</li> <li>hincrByFloat(byte[] key, byte[] field, double value)</li> <li>hexists(String key, String field)</li> <li>hexists(byte[] key, byte[] field)</li> <li>hdel(String key, String... field)</li> <li>hdel(byte[] key, byte[]... field)</li> <li>hlen(String key)</li> <li>hlen(byte[] key)</li> <li>rpush(String key, String... string)</li> <li>rpush(byte[] key, byte[]... args)</li> <li>lpush(String key, String... string)</li> <li>lpush(byte[] key, byte[]... args)</li> <li>llen(String key)</li> <li>llen(byte[] key)</li> <li>lrem(String key, long count, String value)</li> <li>lrem(byte[] key, long count, byte[] value)</li> <li>sadd(String key, String... member)</li> <li>sadd(byte[] key, byte[]... member)</li> <li>scard(String key)</li> <li>scard(byte[] key)</li> <li>sismember(String key, String member)</li> <li>sismember(byte[] key, byte[] member)</li> <li>strlen(String key)</li> <li>strlen(byte[] key)</li> <li>zadd(String key, double score, String member)</li> <li>zadd(byte[] key, double score, byte[] member)</li> <li>zadd(String key, double score, String member, ZAddParams params)</li> <li>zadd(byte[] key, double score, byte[] member, ZAddParams params)</li> <li>zadd(String key, Map scoreMembers) <li>zadd(byte[] key, Map scoreMembers) <li>zadd(String key, Map scoreMembers, ZAddParams params) <li>zadd(byte[] key, Map scoreMembers, ZAddParams params) <li>zrem(String key, String... members)</li> <li>zrem(byte[] key, byte[]... members)</li> <li>zincrby(String key, double increment, String member)</li> <li>zincrby(byte[] key, double increment, byte[] member)</li> <li>zcard(String key)</li> <li>zcard(byte[] key)</li> <li>zcount(String key, double min, double max)</li> <li>zcount(byte[] key, double min, double max)</li> <li>zcount(String key, String min, String max)</li> <li>zcount(byte[] key, byte[] min, byte[] max)</li> <li>zremrangeByRank(String key, long start, long stop)</li> <li>zremrangeByRank(byte[] key, long start, long stop)</li> <li>zremrangeByScore(String key, double min, double max)</li> <li>zremrangeByScore(byte[] key, double min, double max)</li> <li>zremrangeByScore(String key, String min, String max)</li> <li>zremrangeByScore(byte[] key, byte[] min, byte[] max)</li> <li>zlexcount(String key, String min, String max)</li> <li>zlexcount(byte[] key, byte[] min, byte[] max)</li> <li>zremrangeByLex(String key, String min, String max)</li> <li>zremrangeByLex(byte[] key, byte[] min, byte[] max)</li> <li>linsert(String key, ListPosition where, String pivot, String value)</li> <li>linsert(byte[] key, ListPosition where, byte[] pivot, byte[] value)</li> <li>lpushx(String key, String... string)</li> <li>lpushx(byte[] key, byte[]... arg)</li> <li>rpushx(String key, String... string)</li> <li>rpushx(byte[] key, byte[]... arg)</li> <li>del(String key)</li> <li>del(byte[] key)</li> <li>del(String... keys)</li> <li>unlink(String key)</li> <li>unlink(byte[] key)</li> <li>unlink(String... keys)</li> <li>bitcount(String key)</li> <li>bitcount(byte[] key)</li> <li>bitcount(String key, long start, long end)</li> <li>bitcount(byte[] key, long start, long end)</li> <li>bitpos(String key, boolean value)</li> <li>bitpos(String key, boolean value, BitPosParams params)</li> <li>pfadd(String key, String... elements)</li> <li>pfadd(byte[] key, byte[]... elements)</li> <li>pfcount(byte[]... keys)</li> <li>geoadd(String key, double longitude, double latitude, String member)</li> <li>geoadd(byte[] key, double longitude, double latitude, byte[] member)</li> <li>geoadd(String key, Map memberCoordinateMap) <li>geoadd(byte[] key, Map memberCoordinateMap) <li>geoadd(String key, GeoAddParams params, Map memberCoordinateMap) <li>geoadd(byte[] key, GeoAddParams params, Map memberCoordinateMap) <li>hstrlen(String key, String field)</li> <li>hstrlen(byte[] key, byte[] field)</li> <li>xlen(String key)</li> <li>xlen(byte[] key)</li> <li>xack(String key, String group, StreamEntryID... ids)</li> <li>xack(byte[] key, byte[] group, byte[]... ids)</li> <li>xgroupDestroy(String key, String groupname)</li> <li>xgroupDestroy(byte[] key, byte[] consumer)</li> <li>xgroupDelConsumer( String key, String groupname, String consumername)</li> <li>xgroupDelConsumer(byte[] key, byte[] consumer, byte[] consumerName)</li> <li>xdel(String key, StreamEntryID... ids)</li> <li>xdel(byte[] key, byte[]... ids)</li> <li>xtrim(String key, long maxLen, boolean approximate)</li> <li>xtrim(byte[] key, long maxLen, boolean approximateLength)</li> <li>xtrim(String key, XTrimParams params)</li> <li>xtrim(byte[] key, XTrimParams params)</li> <li>clusterKeySlot(String key)</li> <li>clusterCountKeysInSlot(int slot)</li> <li>msetnx(String... keysvalues)</li> <li>msetnx(byte[]... keysvalues)</li> <li>renamenx(String oldkey, String newkey)</li> <li>renamenx(byte[] oldkey, byte[] newkey)</li> <li>sdiffstore(String dstkey, String... keys)</li> <li>sdiffstore(byte[] dstkey, byte[]... keys)</li> <li>sinterstore(String dstkey, String... keys)</li> <li>sinterstore(byte[] dstkey, byte[]... keys)</li> <li>smove(String srckey, String dstkey, String member)</li> <li>smove(byte[] srckey, byte[] dstkey, byte[] member)</li> <li>sort(String key, String dstkey)</li> <li>sort(byte[] key, byte[] dstkey)</li> <li>sort(String key, SortingParams sortingParameters, String dstkey)</li> <li>sort(byte[] key, SortingParams sortingParameters, byte[] dstkey)</li> <li>sunionstore(String dstkey, String... keys)</li> <li>sunionstore(byte[] dstkey, byte[]... keys)</li> <li>zdiffStore(String dstkey, String... keys)</li> <li>zdiffStore(byte[] dstkey, byte[]... keys)</li> <li>zinterstore(String dstkey, String... sets)</li> <li>zinterstore(byte[] dstkey, byte[]... sets)</li> <li>zinterstore(String dstkey, ZParams params, String... sets)</li> <li>zinterstore(byte[] dstkey, ZParams params, byte[]... sets)</li> <li>zunionstore(String dstkey, String... sets)</li> <li>zunionstore(byte[] dstkey, byte[]... sets)</li> <li>zunionstore(String dstkey, ZParams params, String... sets)</li> <li>zunionstore(byte[] dstkey, ZParams params, byte[]... sets)</li> <li>bitop(BitOP op, String destKey, String... srcKeys)</li> <li>bitop(BitOP op, byte[] destKey, byte[]... srcKeys)</li> <li>georadiusStore(String key, double longitude, double latitude, double radius, GeoUnit unit, GeoRadiusParam param, GeoRadiusStoreParam storeParam)</li> <li>georadiusStore(byte[] key, double longitude, double latitude, double radius, GeoUnit unit, GeoRadiusParam param, GeoRadiusStoreParam storeParam)</li> <li>georadiusByMemberStore(String key, String member, double radius, GeoUnit unit, GeoRadiusParam param, GeoRadiusStoreParam storeParam)</li> <li>georadiusByMemberStore(byte[] key, byte[] member, double radius, GeoUnit unit, GeoRadiusParam param, GeoRadiusStoreParam storeParam)</li> <li>copy(String srcKey, String dstKey, int db, boolean replace)</li> <li>copy(byte[] srcKey, byte[] dstKey, int db, boolean replace)</li> <li>copy(String srcKey, String dstKey, boolean replace)</li> <li>copy(byte[] srcKey, byte[] dstKey, boolean replace)</li>"},{"location":"3to4-zset-list/","title":"3to4 zset list","text":""},{"location":"3to4-zset-list/#each-of-the-following-sorted-set-methods-now-return-a-java-list-instead-of-a-set","title":"Each of the following sorted set methods now return a Java <code>List</code> instead of a <code>Set</code>:","text":"<ul> <li>zrange(byte[] key, long start, long stop)</li> <li>zrange(String key, long start, long stop)</li> <li>zrevrange(byte[] key, long start, long stop)</li> <li>zrevrange(String key, long start, long stop)</li> <li>zrangeWithScores(byte[] key, long start, long stop)</li> <li>zrangeWithScores(String key, long start, long stop)</li> <li>zrevrangeWithScores(byte[] key, long start, long stop)</li> <li>zrevrangeWithScores(String key, long start, long stop)</li> <li>zrandmember(byte[] key, long count)</li> <li>zrandmember(String key, long count)</li> <li>zrandmemberWithScores(byte[] key, long count)</li> <li>zrandmemberWithScores(String key, long count)</li> <li>zpopmax(byte[] key, int count)</li> <li>zpopmax(String key, int count)</li> <li>zpopmin(byte[] key, int count)</li> <li>zpopmin(String key, int count)</li> <li>zrangeByScore(byte[] key, double min, double max)</li> <li>zrangeByScore(String key, double min, double max)</li> <li>zrangeByScore(byte[] key, byte[] min, byte[] max)</li> <li>zrangeByScore(String key, String min, String max)</li> <li>zrevrangeByScore(byte[] key, double max, double min)</li> <li>zrevrangeByScore(String key, double max, double min)</li> <li>zrangeByScore(byte[] key, double min, double max, int offset, int count)</li> <li>zrangeByScore(String key, double min, double max, int offset, int count)</li> <li>zrevrangeByScore(byte[] key, byte[] max, byte[] min)</li> <li>zrevrangeByScore(String key, String max, String min)</li> <li>zrangeByScore(byte[] key, byte[] min, byte[] max, int offset, int count)</li> <li>zrangeByScore(String key, String min, String max, int offset, int count)</li> <li>zrevrangeByScore(byte[] key, double max, double min, int offset, int count)</li> <li>zrevrangeByScore(String key, double max, double min, int offset, int count)</li> <li>zrangeByScoreWithScores(byte[] key, double min, double max)</li> <li>zrangeByScoreWithScores(String key, double min, double max)</li> <li>zrevrangeByScoreWithScores(byte[] key, double max, double min)</li> <li>zrevrangeByScoreWithScores(String key, double max, double min)</li> <li>zrangeByScoreWithScores(byte[] key, double min, double max, int offset, int count)</li> <li>zrangeByScoreWithScores(String key, double min, double max, int offset, int count)</li> <li>zrevrangeByScore(byte[] key, byte[] max, byte[] min, int offset, int count)</li> <li>zrevrangeByScore(String key, String max, String min, int offset, int count)</li> <li>zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max)</li> <li>zrangeByScoreWithScores(String key, String min, String max)</li> <li>zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min)</li> <li>zrevrangeByScoreWithScores(String key, String max, String min)</li> <li>zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max, int offset, int count)</li> <li>zrangeByScoreWithScores(String key, String min, String max, int offset, int count)</li> <li>zrevrangeByScoreWithScores(byte[] key, double max, double min, int offset, int count)</li> <li>zrevrangeByScoreWithScores(String key, double max, double min, int offset, int count)</li> <li>zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min, int offset, int count)</li> <li>zrevrangeByScoreWithScores(String key, String max, String min, int offset, int count)</li> <li>zrangeByLex(byte[] key, byte[] min, byte[] max)</li> <li>zrangeByLex(String key, String min, String max)</li> <li>zrangeByLex(byte[] key, byte[] min, byte[] max, int offset, int count)</li> <li>zrangeByLex(String key, String min, String max, int offset, int count)</li> <li>zrevrangeByLex(byte[] key, byte[] max, byte[] min)</li> <li>zrevrangeByLex(String key, String max, String min)</li> <li>zrevrangeByLex(byte[] key, byte[] max, byte[] min, int offset, int count)</li> <li>zrevrangeByLex(String key, String max, String min, int offset, int count)</li> </ul>"},{"location":"3to4/","title":"Jedis 4 Breaking Changes","text":"<ul> <li>The <code>BinaryJedis</code> and <code>BinaryJedisCluster</code> classes have been removed.</li> </ul> <p>The methods from these classes are available in the <code>Jedis</code> and <code>JedisCluster</code> classes   respectively.</p> <ul> <li>The following cases now throws an <code>IllegalStateException</code> instead of a <code>JedisDataException</code>.</li> <li><code>Cannot use Jedis when in Multi. Please use Transaction or reset Jedis state.</code></li> <li> <p><code>Cannot use Jedis when in Pipeline. Please use Pipeline or reset Jedis state.</code></p> </li> <li> <p>The Redis transaction methods <code>multi()</code>, <code>exec()</code> and <code>discard()</code> have   been removed from <code>Pipeline</code>.</p> </li> <li> <p>The <code>execGetResponse()</code> method has been removed from <code>Transaction</code>.</p> </li> <li> <p>The <code>watch()</code> and <code>unwatch()</code> methods from the <code>Transaction</code> class are unsupported within MULTI (i.e., after the <code>multi()</code> method). However, <code>watch()</code> and <code>unwatch ()</code> can still be used before calling MULTI.</p> </li> <li> <p>The <code>JedisCluster</code> constructors with <code>GenericObjectPoolConfig&lt;Jedis&gt;</code> now accept   <code>GenericObjectPoolConfig&lt;Connection&gt;</code>.</p> </li> <li> <p>All <code>JedisCluster</code> constructors now throw a <code>JedisClusterOperationException</code> if unable to connect to any of the provided <code>HostAndPort(s)</code>. Previously, the connection would go into an unusable state.</p> </li> <li> <p><code>JedisCluster.getClusterNodes()</code> returns <code>Map&lt;String, ConnectionPool&gt;</code> instead of   <code>Map&lt;String, JedisPool&gt;</code>.</p> </li> <li> <p><code>JedisCluster.getConnectionFromSlot(int)</code> returns <code>Connection</code> instead of <code>Jedis</code>.</p> </li> <li> <p><code>JedisNoReachableClusterNodeException</code> has been removed. <code>JedisClusterOperationException</code>, with a similar message, is thrown instead.</p> </li> <li> <p><code>JedisClusterMaxAttemptsException</code> has been removed. <code>JedisClusterOperationException</code>, with a similar message, is thrown instead.</p> </li> <li> <p><code>JedisExhaustedPoolException</code> has been removed. A <code>JedisException</code> with a similar message is thrown   instead.</p> </li> <li> <p>Many sorted set methods return a Java <code>List</code> instead of a <code>Set</code>. See the complete list.</p> </li> <li> <p>Many methods return primitive values) (<code>long</code>/<code>boolean</code>/<code>double</code> instead of <code>Long</code>/<code>Boolean</code>/   <code>Double</code>). See the complete list.</p> </li> <li> <p><code>scriptExists(byte[])</code> method now returns <code>Boolean</code> instead of <code>Long</code>.</p> </li> <li> <p><code>scriptExists(byte[]...)</code> method now returns <code>List&lt;Boolean&gt;</code> instead of <code>List&lt;Long&gt;</code>.</p> </li> <li> <p>In the <code>xadd</code> method with StreamEntryID parameter, sending untyped <code>null</code> raises an exception.</p> </li> </ul> <p>Casting the <code>null</code> to StreamEntryID (<code>(StreamEntryID) null</code>) resolves this issue.</p> <ul> <li>In the <code>xrange</code> and   <code>xrevrange</code> methods with StreamEntryID parameters, sending   untyped <code>null</code>s for both start and end parameters raises an exception.</li> </ul> <p>Casting the <code>null</code>s to StreamEntryID (<code>(StreamEntryID) null</code>) resolves this issue.</p> <ul> <li> <p>The return type of <code>Jedis.shutdown()</code> is now <code>void</code>. Previously, it would return null.</p> </li> <li> <p>The <code>eval</code> and <code>evalsha</code> methods are now non-blocking. These methods were blocking in Jedis 3.x.</p> </li> <li> <p>The <code>HostAndPort.localhost</code> constant has been removed.</p> </li> <li> <p>The following methods have been removed from HostAndPort class:</p> </li> <li><code>extractParts()</code></li> <li><code>parseString()</code></li> <li><code>convertHost()</code></li> <li><code>setLocalhost()</code></li> <li><code>getLocalhost()</code></li> <li> <p><code>getLocalHostQuietly()</code></p> </li> <li> <p>The following classes have been moved to the <code>redis.clients.jedis.args</code> package.</p> </li> <li><code>BitOP</code></li> <li><code>GeoUnit</code></li> <li> <p><code>ListPosition</code></p> </li> <li> <p>The following classes have been moved to the <code>redis.clients.jedis.params</code> package.</p> </li> <li><code>BitPosParams</code></li> <li><code>ScanParams</code></li> <li><code>SortingParams</code></li> <li> <p><code>ZParams</code></p> </li> <li> <p>The following classes have been moved to the <code>redis.clients.jedis.resps</code> package.</p> </li> <li><code>AccessControlLogEntry</code></li> <li><code>AccessControlUser</code></li> <li><code>GeoRadiusResponse</code></li> <li><code>ScanResult</code></li> <li><code>Slowlog</code></li> <li><code>StreamConsumersInfo</code></li> <li><code>StreamEntry</code></li> <li><code>StreamGroupInfo</code></li> <li><code>StreamInfo</code></li> <li><code>StreamPendingEntry</code></li> <li><code>StreamPendingSummary</code></li> <li> <p><code>Tuple</code></p> </li> <li> <p>Jedis and JedisPool constructors with a <code>String</code> parameter, and no <code>int</code> parameter, only support a URL or URI string.</p> </li> <li>Jedis(String)</li> <li>JedisPool(String)</li> <li>JedisPool(String, SSLSocketFactory, SSLParameters, HostnameVerifier)</li> <li> <p>JedisPool(GenericObjectPoolConfig, String) <li> <p>The <code>Client</code> and <code>BinaryClient</code> classes have been removed.</p> </li> <li> <p><code>redis.clients.jedis.commands</code> package has been reimplemented, meaning that the <code>Commands</code> interfaces have been restructured.</p> </li> <li> <p>The <code>ShardedJedisPool</code>, <code>Sharded</code>, <code>ShardedJedis</code>, <code>BinaryShardedJedis</code>, <code>ShardInfo</code>, <code>JedisShardInfo</code> classes have been removed.</p> </li> <li> <p>Introduced <code>JedisSharding</code> class to replace <code>ShardedJedisPool</code>.</p> <p>Earlier code without the use of \"name\" and \"weight\" (in ShardInfo/JedisShardInfo) are transferable to the new class.</p> </li> <li> <p><code>ShardedJedisPipeline</code> class has been removed.</p> </li> <li> <p>Introduced <code>ShardedPipeline</code> class to replace <code>ShardedJedisPipeline</code>.</p> </li> <li> <p>The type of <code>Protocol.CHARSET</code> has been changed to <code>java.nio.charset.Charset</code>.</p> </li> <li> <p><code>Jedis.debug(DebugParams)</code> method has been removed.</p> </li> <li> <p>The <code>DebugParams</code> class has been removed.</p> </li> <li> <p>The <code>Jedis.sync()</code> method has been removed.</p> </li> <li> <p>The <code>Jedis.pubsubNumSub(String...)</code> method now returns <code>Map&lt;String, Long&gt;</code> instead of <code>Map&lt;String, String&gt;</code>.</p> </li> <li> <p><code>setDataSource</code> method in Jedis class now has <code>protected</code> access.</p> </li> <li> <p><code>JedisPoolAbstract</code> class has been removed. Use <code>Pool&lt;Jedis&gt;</code>.</p> </li> <li> <p>The <code>Pool.initPool()</code> method has been removed.</p> </li> <li> <p>The <code>Pool.getNumActive()</code> method now returns <code>0</code> (via GenericObjectPool) when the pool is closed.</p> </li> <li> <p>The <code>Connection.getRawObjectMultiBulkReply()</code> method has been removed. Use   <code>Connection.getUnflushedObjectMultiBulkReply()</code> method.</p> </li> <li> <p>The <code>Queable.getResponse(Builder&lt;T&gt; builder)</code> method has been renamed to   <code>Queable.enqueResponse(Builder&lt;T&gt; builder)</code>.</p> </li> <li> <p>All methods in Queable are now <code>final</code>:</p> </li> <li><code>clean()</code></li> <li><code>generateResponse(Object data)</code></li> <li><code>enqueResponse(Builder&lt;T&gt; builder)</code></li> <li> <p><code>getPipelinedResponseLength()</code></p> </li> <li> <p>These BuilderFactory implementations have been removed:</p> </li> <li><code>OBJECT</code> (use <code>RAW_OBJECT</code>)</li> <li><code>BYTE_ARRAY_ZSET</code> (use <code>BINARY_LIST</code> or <code>BINARY_SET</code>)</li> <li><code>BYTE_ARRAY_MAP</code> (use <code>BINARY_MAP</code>)</li> <li><code>STRING_ZSET</code> (use <code>STRING_LIST</code> or <code>STRING_SET</code>)</li> <li><code>EVAL_RESULT</code> (use <code>ENCODED_OBJECT</code>)</li> <li> <p><code>EVAL_BINARY_RESULT</code> (use <code>RAW_OBJECT</code>)</p> </li> <li> <p>All String variables representing Cluster, Sentinel and PubSub subcommands in Protocol class   have been removed.</p> </li> <li> <p><code>ClientKillParams.Type</code> has been removed. Use <code>ClientType</code>.</p> </li> <li> <p><code>ClusterReset</code> has been removed. Use <code>ClusterResetType</code>.</p> </li> <li> <p>The <code>JedisClusterHostAndPortMap</code> interface has been removed. Use the <code>HostAndPortMapper</code> interface.</p> </li> <li> <p><code>JedisClusterHashTagUtil</code> class has been renamed to <code>JedisClusterHashTag</code>.</p> </li> <li> <p>The <code>KeyMergeUtil</code> class has been removed.</p> </li>"},{"location":"breaking-5/","title":"Jedis 5 Breaking Changes","text":"<ul> <li> <p>All variants of <code>blmpop</code> and <code>bzmpop</code> methods now take <code>double timeout</code> parameter instead of <code>long timeout</code> parameter.   This is breaking ONLY IF you are using <code>Long</code> for timeout.</p> </li> <li> <p><code>Reducer</code> abstract class is refactored:</p> </li> <li><code>Reducer(String field)</code> constructor is removed; <code>Reducer(String name, String field)</code> constructor is added.</li> <li><code>Reducer(String name)</code> constructor is added; it will cause runtime error with older <code>Reducer(String field)</code> constructor.</li> <li><code>getName</code> method is removed.</li> <li><code>getAlias</code> method is removed.</li> <li><code>setAlias</code> method is removed; use <code>as</code> method.</li> <li><code>setAliasAsField</code> method is removed.</li> <li><code>getOwnArgs</code> method is now abstract.</li> <li> <p><code>getArgs</code> method is removed.</p> </li> <li> <p><code>quit()</code> method has been removed from <code>Connection</code> and <code>ServerCommands</code> interface and implementations.</p> </li> <li> <p><code>updatePassword(String password)</code> method has been removed from <code>JedisClientConfig</code> and implementations.</p> </li> <li> <p><code>setPassword(String password)</code> method has been removed from both <code>JedisFactory</code> and <code>ConnectionFactory</code> classes.</p> </li> <li> <p>Both <code>bzpopmax(double timeout, String... keys)</code> and <code>bzpopmin(double timeout, String... keys)</code> now return <code>KeyValue&lt;String, Tuple&gt;</code> (instead of <code>KeyedZSetElement</code>).</p> </li> <li> <p>Both <code>bzpopmax(double timeout, byte[]... keys)</code> and <code>bzpopmin(double timeout, byte[]... keys)</code> now return <code>KeyValue&lt;byte[], Tuple&gt;</code> (instead of <code>List&lt;byte[]&gt;</code>).</p> </li> <li> <p>Following methods now return <code>KeyValue&lt;String, String&gt;</code> instead of <code>KeyedListElement</code>:</p> </li> <li><code>blpop(double timeout, String key)</code></li> <li><code>blpop(double timeout, String... keys)</code></li> <li><code>brpop(double timeout, String key)</code></li> <li> <p><code>brpop(double timeout, String... keys)</code></p> </li> <li> <p>Following methods now return <code>KeyValue&lt;byte[], byte[]&gt;</code> instead of <code>List&lt;byte[]&gt;</code>:</p> </li> <li><code>blpop(double timeout, byte[]... keys)</code></li> <li> <p><code>brpop(double timeout, byte[]... keys)</code></p> </li> <li> <p><code>zdiff(String... keys)</code> method now returns <code>List&lt;String&gt;</code> (instead of <code>Set&lt;String&gt;</code>).</p> </li> <li><code>zdiff(byte[]... keys)</code> method now returns <code>List&lt;byte[]&gt;</code> (instead of <code>Set&lt;byte[]&gt;</code>).</li> <li> <p>Both <code>zdiffWithScores(String... keys)</code> and <code>zdiffWithScores(byte[]... keys)</code> methods now return <code>List&lt;Tuple&gt;</code> (instead of <code>Set&lt;Tuple&gt;</code>).</p> </li> <li> <p><code>zinter(ZParams params, String... keys)</code> method now returns <code>List&lt;String&gt;</code> (instead of <code>Set&lt;String&gt;</code>).</p> </li> <li><code>zinter(ZParams params, byte[]... keys)</code> method now returns <code>List&lt;byte[]&gt;</code> (instead of <code>Set&lt;byte[]&gt;</code>).</li> <li> <p>Both <code>zinterWithScores(ZParams params, String... keys)</code> and <code>zinterWithScores(ZParams params, byte[]... keys)</code> methods now return <code>List&lt;Tuple&gt;</code> (instead of <code>Set&lt;Tuple&gt;</code>).</p> </li> <li> <p><code>zunion(ZParams params, String... keys)</code> method now returns <code>List&lt;String&gt;</code> (instead of <code>Set&lt;String&gt;</code>).</p> </li> <li><code>zunion(ZParams params, byte[]... keys)</code> method now returns <code>List&lt;byte[]&gt;</code> (instead of <code>Set&lt;byte[]&gt;</code>).</li> <li> <p>Both <code>zunionWithScores(ZParams params, String... keys)</code> and <code>zunionWithScores(ZParams params, byte[]... keys)</code> methods now return <code>List&lt;Tuple&gt;</code> (instead of <code>Set&lt;Tuple&gt;</code>).</p> </li> <li> <p>Both <code>configGet(String pattern)</code> and <code>configGet(String... patterns)</code> methods now return <code>Map&lt;String, String&gt;</code> instead of <code>List&lt;String&gt;</code>.</p> </li> <li> <p>Both <code>configGet(byte[] pattern)</code> and <code>configGet(byte[]... patterns)</code> methods now return <code>Map&lt;byte[], byte[]&gt;</code> instead of <code>List&lt;byte[]&gt;</code>.</p> </li> <li> <p>New <code>aclDelUser(String... names)</code> method replaces <code>aclDelUser(String name)</code> and <code>aclDelUser(String name, String... names)</code> methods.</p> </li> <li> <p>New <code>aclDelUser(byte[]... names)</code> method replaces <code>aclDelUser(byte[] name)</code> and <code>aclDelUser(byte[] name, byte[]... names)</code> methods.</p> </li> <li> <p><code>tsMGet(TSMGetParams multiGetParams, String... filters)</code> method now returns <code>Map&lt;String, TSMGetElement&gt;</code> instead of <code>List&lt;TSKeyValue&lt;TSElement&gt;&gt;</code>.</p> </li> <li> <p>Following methods now return <code>Map&lt;String, TSMRangeElements&gt;</code> instead of <code>List&lt;TSKeyedElements&gt;</code>:</p> </li> <li><code>tsMRange(long fromTimestamp, long toTimestamp, String... filters)</code></li> <li><code>tsMRange(TSMRangeParams multiRangeParams)</code></li> <li><code>tsMRevRange(long fromTimestamp, long toTimestamp, String... filters)</code></li> <li> <p><code>tsMRevRange(TSMRangeParams multiRangeParams)</code></p> </li> <li> <p><code>jsonNumIncrBy(String key, Path2 path, double value)</code> method now returns <code>Object</code> instead of <code>JSONArray</code>.</p> </li> <li>The returning object would still be JSONArray for all previous cases. So simple type casting is enough to handle this change.</li> <li> <p>The returning object will be <code>List&lt;Double&gt;</code> when running under RESP3 protocol.</p> </li> <li> <p><code>getAgeSeconds()</code> in <code>AccessControlLogEntry</code> now returns <code>Double</code> instead of <code>String</code>.</p> </li> <li> <p>Both <code>ftConfigGet(String option)</code> and <code>ftConfigGet(String indexName, String option)</code> methods now return <code>Map&lt;String, Object&gt;</code> instead of <code>Map&lt;String, String&gt;</code>.</p> </li> <li> <p><code>ftList()</code> method now returns <code>Set&lt;String&gt;</code> instead of <code>List&lt;String&gt;</code>.</p> </li> <li> <p><code>graphSlowlog(String graphName)</code> now returns <code>List&lt;List&lt;Object&gt;&gt;</code> (instead of <code>List&lt;List&lt;String&gt;&gt;</code>).</p> </li> <li> <p><code>CommandListFilterByParams</code> now throws <code>IllegalArgumentException</code> (instead of <code>JedisDataException</code>) in case of unfulfilling filter.</p> </li> <li> <p><code>FailoverParams</code> now throws <code>IllegalArgumentException</code> (instead of <code>IllegalStateException</code>) in case of unfulfilling optional arguments.</p> </li> <li> <p><code>XPendingParams</code> now throws <code>IllegalArgumentException</code> (instead of <code>IllegalStateException</code>) in case of unfulfilling optional arguments.</p> </li> <li> <p><code>get()</code> option has been removed from <code>SetParams</code>.  Following methods have been added in Jedis/UnifiedJedis for convenience:</p> </li> <li><code>setGet(String key, String value)</code> method has been added in <code>StringCommands</code> interface.</li> <li> <p><code>setGet(byte[] key, byte[] value)</code> method has been added in <code>StringBinaryCommands</code> interface.</p> </li> <li> <p><code>xpending(String key, String groupName, StreamEntryID start, StreamEntryID end, int count, String consumerName)</code> method has been removed from everywhere.</p> </li> <li> <p>Use <code>xpending(java.lang.String, java.lang.String, redis.clients.jedis.params.XPendingParams)</code> instead.</p> </li> <li> <p><code>xpending(byte[] key, byte[] groupName, byte[] start, byte[] end, int count, byte[] consumerName)</code> method has been removed from everywhere.</p> </li> <li> <p>Use <code>xpending(byte[], byte[], redis.clients.jedis.params.XPendingParams)</code> instead.</p> </li> <li> <p><code>retentionTime(long retentionTime)</code> method in <code>TSAlterParams</code> has been removed. Use <code>retention(long)</code> method instead.</p> </li> <li> <p>Following classes have been removed:</p> </li> <li><code>KeyedZSetElement</code></li> <li><code>KeyedListElement</code></li> <li><code>TSKeyValue</code></li> <li><code>TSKeyedElements</code></li> <li> <p><code>Limit</code></p> </li> <li> <p>Following BuilderFactory implementations have been removed:</p> </li> <li><code>BYTE_ARRAY</code> (use <code>BINARY</code>)</li> <li><code>BYTE_ARRAY_LIST</code> (use <code>BINARY_LIST</code>)</li> <li><code>BINARY_MAP_FROM_PAIRS</code></li> <li> <p><code>STRING_ORDERED_SET</code></p> </li> <li> <p>All payload related parameters are removed from search related classes; namely <code>Document</code>, <code>IndexDefinition</code>, <code>Query</code>.</p> </li> <li> <p><code>topkCount(String key, String... items)</code> method has been removed from everywhere.</p> </li> <li> <p>Following methods supporting JSON.RESP command have been removed:</p> </li> <li><code>jsonResp(String key)</code></li> <li><code>jsonResp(String key, Path path)</code></li> <li> <p><code>jsonResp(String key, Path2 path)</code></p> </li> <li> <p><code>RedisJsonCommands</code> and <code>RedisJsonPipelineCommands</code> interfaces have been moved into <code>redis.clients.jedis.json.commands</code> package.</p> </li> <li> <p><code>AbortedTransactionException</code> is removed.</p> </li> <li> <p><code>Queable</code> class is removed.</p> </li> <li> <p><code>Params</code> abstract class is removed.</p> </li> <li> <p><code>toString()</code> support used by its sub-classes is now unavailable.</p> </li> <li> <p><code>getParams()</code> method is removed from <code>SortingParams</code> class.</p> </li> <li> <p>Both <code>SEARCH_AGGREGATION_RESULT</code> and <code>SEARCH_AGGREGATION_RESULT_WITH_CURSOR</code> implementations from <code>SearchBuilderFactory</code> class have been moved to <code>AggregationResult</code> class.</p> </li> <li> <p>All <code>AggregationResult</code> constructors have been made <code>private</code>.</p> </li> <li> <p><code>getArgs()</code>, <code>getArgsString()</code> and <code>serializeRedisArgs(List&lt;byte[]&gt; redisArgs)</code> methods have been removed from <code>AggregationBuilder</code>.</p> </li> <li> <p><code>totalResults</code> variable in <code>AggregationResult</code> has been made private. Use <code>getTotalResults()</code> method instead.</p> </li> <li> <p><code>getArgs()</code> and <code>limit(Limit limit)</code> methods have been removed from <code>Group</code> class.</p> </li> <li> <p><code>addCommandEncodedArguments</code> and <code>addCommandBinaryArguments</code> methods have been removed from <code>FieldName</code> class.</p> </li> <li> <p><code>addObjects(int[] ints)</code> method has been removed from <code>CommandArguments</code>.</p> </li> <li> <p>Following methods have been removed:</p> </li> <li><code>strAlgoLCSStrings(String strA, String strB, StrAlgoLCSParams params)</code></li> <li><code>strAlgoLCSStrings(byte[] strA, byte[] strB, StrAlgoLCSParams params)</code></li> <li><code>strAlgoLCSKeys(String keyA, String keyB, StrAlgoLCSParams params)</code></li> <li> <p><code>strAlgoLCSKeys(byte[] keyA, byte[] keyB, StrAlgoLCSParams params)</code></p> </li> <li> <p><code>StrAlgoLCSParams</code> class has been removed.</p> </li> <li> <p>Following methods have been removed from all Pipeline classes:</p> </li> <li><code>ftCursorRead(String indexName, long cursorId, int count)</code></li> <li><code>ftCursorDel(String indexName, long cursorId)</code></li> <li><code>ftDropIndex(String indexName)</code></li> <li><code>ftDropIndexDD(String indexName)</code></li> <li><code>ftAliasAdd(String aliasName, String indexName)</code></li> <li><code>ftAliasUpdate(String aliasName, String indexName)</code></li> <li> <p><code>ftAliasDel(String aliasName)</code></p> </li> <li> <p><code>JedisSentineled(String masterName, Set&lt;HostAndPort&gt; sentinels, JedisClientConfig masterClientConfig, JedisClientConfig sentinelClientConfig)</code> and <code>JedisSentineled(String masterName, Set&lt;HostAndPort&gt; sentinels, GenericObjectPoolConfig&lt;Connection&gt; poolConfig, JedisClientConfig masterClientConfig, JedisClientConfig sentinelClientConfig)</code> constructors have been removed.</p> </li> <li> <p><code>JedisClusterInfoCache(JedisClientConfig clientConfig)</code> and <code>JedisClusterInfoCache(JedisClientConfig clientConfig, GenericObjectPoolConfig&lt;Connection&gt; poolConfig)</code> constructors have been removed.</p> </li> </ul>"},{"location":"failover/","title":"Failover with Jedis","text":"<p>Jedis supports failover for your Redis deployments. This is useful when: 1. You have more than one Redis deployment. This might include two independent Redis servers or two or more Redis databases replicated across multiple active-active Redis Enterprise clusters. 2. You want your application to connect to and use one deployment at a time. 3. You want your application to fail over to the next available deployment if the current deployment becomes unavailable.</p> <p>Jedis will fail over to a subsequent Redis deployment after reaching a configurable failure threshold. This failure threshold is implemented using a circuit breaker pattern.</p> <p>You can also configure Jedis to retry failed calls to Redis. Once a maximum number of retries have been exhausted, the circuit breaker will record a failure. When the circuit breaker reaches its failure threshold, a failover will be triggered on the subsequent operation.</p> <p>The remainder of this guide describes:</p> <ul> <li>A basic failover configuration</li> <li>Supported retry and circuit breaker settings</li> <li>Failback and the cluster selection API</li> </ul> <p>We recommend that you read this guide carefully and understand the configuration settings before enabling Jedis failover in production.</p>"},{"location":"failover/#basic-usage","title":"Basic usage","text":"<p>To configure Jedis for failover, you specify an ordered list of Redis databases. By default, Jedis will connect to the first Redis database in the list. If the first database becomes unavailable, Jedis will attempt to connect to the next database in the list, and so on.</p> <p>Suppose you run two Redis deployments. We'll call them <code>redis-east</code> and <code>redis-west</code>. You want your application to first connect to <code>redis-east</code>. If <code>redis-east</code> becomes unavailable, you want your application to connect to <code>redis-west</code>.</p> <p>Let's look at one way of configuring Jedis for this scenario.</p> <p>First, create an array of <code>ClusterConfig</code> objects, one for each Redis database.</p> <pre><code>JedisClientConfig config = DefaultJedisClientConfig.builder().user(\"cache\").password(\"secret\").build();\n\nClusterConfig[] clientConfigs = new ClusterConfig[2];\nclientConfigs[0] = new ClusterConfig(new HostAndPort(\"redis-east.example.com\", 14000), config);\nclientConfigs[1] = new ClusterConfig(new HostAndPort(\"redis-west.example.com\", 14000), config);\n</code></pre> <p>The configuration above represents your two Redis deployments: <code>redis-east</code> and <code>redis-west</code>. You'll use this array of configuration objects to create a connection provider that supports failover.</p> <p>Use the <code>MultiClusterClientConfig</code> builder to set your preferred retry and failover configuration, passing in the client configs you just created. Then build a <code>MultiClusterPooledConnectionProvider</code>.</p> <pre><code>MultiClusterClientConfig.Builder builder = new MultiClusterClientConfig.Builder(clientConfigs);\nbuilder.circuitBreakerSlidingWindowSize(10);\nbuilder.circuitBreakerSlidingWindowMinCalls(1);\nbuilder.circuitBreakerFailureRateThreshold(50.0f);\n\nMultiClusterPooledConnectionProvider provider = new MultiClusterPooledConnectionProvider(builder.build());\n</code></pre> <p>Internally, the connection provider uses a highly configurable circuit breaker and retry implementation to determine when to fail over. In the configuration here, we've set a sliding window size of 10 and a failure rate threshold of 50%. This means that a failover will be triggered if 5 out of any 10 calls to Redis fail.</p> <p>Once you've configured and created a <code>MultiClusterPooledConnectionProvider</code>, instantiate a <code>UnifiedJedis</code> instance for your application, passing in the provider you just created:</p> <pre><code>UnifiedJedis jedis = new UnifiedJedis(provider);\n</code></pre> <p>You can now use this <code>UnifiedJedis</code> instance, and the connection management and failover will be handled transparently.</p>"},{"location":"failover/#configuration-options","title":"Configuration options","text":"<p>Under the hood, Jedis' failover support relies on resilience4j, a fault-tolerance library that implements retry and circuit breakers.</p> <p>Once you configure Jedis for failover using the <code>MultiClusterPooledConnectionProvider</code>, each call to Redis is decorated with a resilience4j retry and circuit breaker.</p> <p>By default, any call that throws a <code>JedisConnectionException</code> will be retried up to 3 times. If the call continues to fail after the maximum number of retry attempts, then the circuit breaker will record a failure.</p> <p>The circuit breaker maintains a record of failures in a sliding window data structure. If the failure rate reaches a configured threshold (e.g., when 50% of the last 10 calls have failed), then the circuit breaker's state transitions from <code>CLOSED</code> to <code>OPEN</code>. When this occurs, Jedis will attempt to connect to the next Redis database in its client configuration list.</p> <p>The supported retry and circuit breaker settings, and their default values, are described below. You can configure any of these settings using the <code>MultiClusterClientConfig.Builder</code> builder. Refer the basic usage above for an example of this.</p>"},{"location":"failover/#retry-configuration","title":"Retry configuration","text":"<p>Jedis uses the following retry settings:</p> Setting Default value Description Max retry attempts 3 Maximum number of retry attempts (including the initial call) Retry wait duration 500 ms Number of milliseconds to wait between retry attempts Wait duration backoff multiplier 2 Exponential backoff factor multiplied against wait duration between retries. For example, with a wait duration of 1 second and a multiplier of 2, the retries would occur after 1s, 2s, 4s, 8s, 16s, and so on. Retry included exception list [JedisConnectionException] A list of Throwable classes that count as failures and should be retried. Retry ignored exception list null A list of Throwable classes to explicitly ignore for the purposes of retry. <p>To disable retry, set <code>maxRetryAttempts</code> to 1.</p>"},{"location":"failover/#circuit-breaker-configuration","title":"Circuit breaker configuration","text":"<p>Jedis uses the following circuit breaker settings:</p> Setting Default value Description Sliding window type <code>COUNT_BASED</code> The type of sliding window used to record the outcome of calls. Options are <code>COUNT_BASED</code> and <code>TIME_BASED</code>. Sliding window size 100 The size of the sliding window. Units depend on sliding window type. When <code>COUNT_BASED</code>, the size represents number of calls. When <code>TIME_BASED</code>, the size represents seconds. Sliding window min calls 100 Minimum number of calls required (per sliding window period) before the CircuitBreaker will start calculating the error rate or slow call rate. Failure rate threshold <code>50.0f</code> Percentage of calls within the sliding window that must fail before the circuit breaker transitions to the <code>OPEN</code> state. Slow call duration threshold 60000 ms Duration threshold above which calls are classified as slow and added to the sliding window. Slow call rate threshold <code>100.0f</code> Percentage of calls within the sliding window that exceed the slow call duration threshold before circuit breaker transitions to the <code>OPEN</code> state. Circuit breaker included exception list [JedisConnectionException] A list of Throwable classes that count as failures and add to the failure rate. Circuit breaker ignored exception list null A list of Throwable classes to explicitly ignore for failure rate calculations."},{"location":"failover/#fallback-configuration","title":"Fallback configuration","text":"<p>Jedis uses the following fallback settings:</p> Setting Default value Description Fallback exception list [CallNotPermittedException, JedisConnectionException] A list of Throwable classes that trigger fallback."},{"location":"failover/#failover-callbacks","title":"Failover callbacks","text":"<p>In the event that Jedis fails over, you may wish to take some action. This might include logging a warning, recording a metric, or externally persisting the cluster connection state, to name just a few examples. For this reason, <code>MultiPooledConnectionProvider</code> lets you register a custom callback that will be called whenever Jedis fails over to a new cluster.</p> <p>To use this feature, you'll need to design a class that implements <code>java.util.function.Consumer</code>. This class must implement the <code>accept</code> method, as you can see below.</p> <pre><code>import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.function.Consumer;\n\npublic class FailoverReporter implements Consumer&lt;String&gt; {\n\n    @Override\n    public void accept(String clusterName) {\n        Logger logger = LoggerFactory.getLogger(FailoverReporter.class);\n        logger.warn(\"Jedis failover to cluster: \" + clusterName);\n    }\n}\n</code></pre> <p>You can then pass an instance of this class to your <code>MultiPooledConnectionProvider</code>.</p> <pre><code>FailoverReporter reporter = new FailoverReporter();\nprovider.setClusterFailoverPostProcessor(reporter);\n</code></pre> <p>The provider will call your <code>accept</code> whenever a faoliver occurs.</p>"},{"location":"failover/#failing-back","title":"Failing back","text":"<p>We believe that failback should not be automatic. If Jedis fails over to a new cluster, Jedis will not automatically fail back to the cluster that it was previously connected to. This design prevents a scenario in which Jedis fails back to a cluster that may not be entirely healthy yet.</p> <p>That said, we do provide an API that you can use to implement automated failback when this is appropriate for your application.</p>"},{"location":"failover/#failback-scenario","title":"Failback scenario","text":"<p>When a failover is triggered, Jedis will attempt to connect to the next Redis server in the list of server configurations you provide at setup.</p> <p>For example, recall the <code>redis-east</code> and <code>redis-west</code> deployments from the basic usage example above. Jedis will attempt to connect to <code>redis-east</code> first. If <code>redis-east</code> becomes unavailable (and the circuit breaker transitions), then Jedis will attempt to use <code>redis-west</code>.</p> <p>Now suppose that <code>redis-east</code> eventually comes back online. You will likely want to fail your application back to <code>redis-east</code>. However, Jedis will not fail back to <code>redis-east</code> automatically.</p> <p>In this case, we recommend that you first ensure that your <code>redis-east</code> deployment is healthy before you fail back your application.</p>"},{"location":"failover/#failback-behavior-and-cluster-selection-api","title":"Failback behavior and cluster selection API","text":"<p>Once you've determined that it's safe to fail back to a previously-unavailable cluster, you need to decide how to trigger the failback. There are two ways to accomplish this:</p> <ol> <li>Use the cluster selection API</li> <li>Restart your application</li> </ol>"},{"location":"failover/#fail-back-using-the-cluster-selection-api","title":"Fail back using the cluster selection API","text":"<p><code>MultiClusterPooledConnectionProvider</code> exposes a method that you can use to manually select which cluster Jedis should use. To select a different cluster to use, pass the cluster's numeric index to <code>setActiveMultiClusterIndex()</code>.</p> <p>The cluster's index is a 1-based index derived from its position in the client configuration. For example, suppose you configure Jedis with the following client configs:</p> <pre><code>ClusterConfig[] clientConfigs = new ClusterConfig[2];\nclientConfigs[0] = new ClusterConfig(new HostAndPort(\"redis-east.example.com\", 14000), config);\nclientConfigs[1] = new ClusterConfig(new HostAndPort(\"redis-west.example.com\", 14000), config);\n</code></pre> <p>In this case, <code>redis-east</code> will have an index of <code>1</code>, and <code>redis-west</code> will have an index of <code>2</code>. To select and fail back to <code>redis-east</code>, you would call the function like so:</p> <pre><code>provider.setActiveMultiClusterIndex(1);\n</code></pre> <p>This method is thread-safe.</p> <p>If you decide to implement manual failback, you will need a way for external systems to trigger this method in your application. For example, if your application exposes a REST API, you might consider creating a REST endpoint to call <code>setActiveMultiClusterIndex</code> and fail back the application.</p>"},{"location":"failover/#fail-back-by-restarting-the-application","title":"Fail back by restarting the application","text":"<p>When your application starts, Jedis will attempt to connect to each cluster in the order that the clusters appear in your client configuration. It's important to understand this, especially in the case where Jedis has failed over. If Jedis has failed over to a new cluster, then restarting the application may result in an inadvertent failback. This can happen only if a failed cluster comes back online and the application subsequently restarts. </p> <p>If you need to avoid this scenario, consider using a failover callback, as described above, to externally record the name of the cluster that your application was most recently connected to. You can then check this state on startup to ensure that you application only connects to the most recently used cluster. For assistance with this technique, start a discussion.</p>"},{"location":"jedis-maven/","title":"Jedis maven","text":""},{"location":"jedis-maven/#use-jedis-as-a-maven-dependency","title":"Use Jedis as a maven dependency:","text":""},{"location":"jedis-maven/#official-releases","title":"Official Releases","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;redis.clients&lt;/groupId&gt;\n    &lt;artifactId&gt;jedis&lt;/artifactId&gt;\n    &lt;version&gt;5.0.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"jedis-maven/#snapshots","title":"Snapshots","text":"<pre><code>  &lt;repositories&gt;\n    &lt;repository&gt;\n      &lt;id&gt;snapshots-repo&lt;/id&gt;\n      &lt;url&gt;https://oss.sonatype.org/content/repositories/snapshots&lt;/url&gt;\n    &lt;/repository&gt;\n  &lt;/repositories&gt;\n</code></pre> <p>and</p> <pre><code>  &lt;dependencies&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;redis.clients&lt;/groupId&gt;\n      &lt;artifactId&gt;jedis&lt;/artifactId&gt;\n      &lt;version&gt;5.1.0-SNAPSHOT&lt;/version&gt;\n    &lt;/dependency&gt;\n  &lt;/dependencies&gt;\n</code></pre>"},{"location":"redisearch/","title":"RediSearch Jedis Quick Start","text":"<p>To use RediSearch features with Jedis, you'll need to use an implementation of RediSearchCommands.</p>"},{"location":"redisearch/#creating-the-redisearch-client","title":"Creating the RediSearch client","text":"<p>Initializing the client with JedisPooled:</p> <pre><code>JedisPooled client = new JedisPooled(\"localhost\", 6379);\n</code></pre> <p>Initializing the client with JedisCluster:</p> <pre><code>Set&lt;HostAndPort&gt; nodes = new HashSet&lt;&gt;();\nnodes.add(new HostAndPort(\"127.0.0.1\", 7379));\nnodes.add(new HostAndPort(\"127.0.0.1\", 7380));\n\nJedisCluster client = new JedisCluster(nodes);\n</code></pre>"},{"location":"redisearch/#indexing-and-querying","title":"Indexing and querying","text":""},{"location":"redisearch/#indexing","title":"Indexing","text":"<p>Defining a schema for an index and creating it:</p> <pre><code>Schema sc = new Schema()\n        .addTextField(\"title\", 5.0)\n        .addTextField(\"body\", 1.0)\n        .addNumericField(\"price\");\n\nIndexDefinition def = new IndexDefinition()\n        .setPrefixes(new String[]{\"item:\", \"product:\"})\n        .setFilter(\"@price&gt;100\");\n\nclient.ftCreate(\"item-index\", IndexOptions.defaultOptions().setDefinition(def), sc);\n</code></pre> <p>Alternatively, we can create the same index using FTCreateParams:</p> <pre><code>client.ftCreate(\"item-index\",\n\n        FTCreateParams.createParams()\n                .prefix(\"item:\", \"product:\")\n                .filter(\"@price&gt;100\"),\n\n        TextField.of(\"title\").weight(5.0),\n        TextField.of(\"body\"),\n        NumericField.of(\"price\")\n);\n</code></pre>"},{"location":"redisearch/#inserting","title":"Inserting","text":"<p>Adding documents to the index:</p> <pre><code>Map&lt;String, Object&gt; fields = new HashMap&lt;&gt;();\nfields.put(\"title\", \"hello world\");\nfields.put(\"state\", \"NY\");\nfields.put(\"body\", \"lorem ipsum\");\nfields.put(\"price\", 1337);\n\nclient.hset(\"item:hw\", RediSearchUtil.toStringMap(fields));\n</code></pre> <p>Another way to insert documents:</p> <pre><code>client.hsetObject(\"item:hw\", fields);\n</code></pre>"},{"location":"redisearch/#querying","title":"Querying","text":"<p>Searching the index:</p> <pre><code>Query q = new Query(\"hello world\")\n        .addFilter(new Query.NumericFilter(\"price\", 0, 1000))\n        .limit(0, 5);\n\nSearchResult sr = client.ftSearch(\"item-index\", q);\n</code></pre> <p>Alternative searching using FTSearchParams:</p> <pre><code>SearchResult sr = client.ftSearch(\"item-index\",\n        \"hello world\",\n        FTSearchParams.searchParams()\n                .filter(\"price\", 0, 1000)\n                .limit(0, 5));\n</code></pre> <p>Aggregation query:</p> <pre><code>AggregationBuilder ab = new AggregationBuilder(\"hello\")\n        .apply(\"@price/1000\", \"k\")\n        .groupBy(\"@state\", Reducers.avg(\"@k\").as(\"avgprice\"))\n        .filter(\"@avgprice&gt;=2\")\n        .sortBy(10, SortedField.asc(\"@state\"));\n\nAggregationResult ar = client.ftAggregate(\"item-index\", ab);\n</code></pre>"},{"location":"redisjson/","title":"RedisJSON Jedis Quick Start","text":"<p>Jedis supports RedisJSON and RediSearch.</p> <p>The latest versions of RedisJSON let you store, manipulate, index, and query JSON. To use these features with Jedis, you'll need to use the <code>UnifiedJedis</code> interface or a sub-class of it.</p> <p>Let's see how this works.</p>"},{"location":"redisjson/#creating-with-redisjson-client","title":"Creating with RedisJSON client","text":"<p>First, let's create a <code>JedisPooled</code> client instance:</p> <pre><code>JedisPooled client = new JedisPooled(\"localhost\", 6479);\n</code></pre> <p>Or, a <code>JedisCluster</code> client instance:</p> <pre><code>Set&lt;HostAndPort&gt; nodes = new HashSet&lt;&gt;();\nnodes.add(new HostAndPort(\"127.0.0.1\", 7379));\nnodes.add(new HostAndPort(\"127.0.0.1\", 7380));\n\nJedisCluster client = new JedisCluster(nodes);\n</code></pre> <p>Now we can start working with JSON. For these examples, we'll be using GSON to handle the serialization of POJOs to JSON.</p>"},{"location":"redisjson/#creating-json-documents","title":"Creating JSON documents","text":"<p>Suppose we're building an online learning platform, and we want to represent students. Let's create a POJO to represent our students:</p> <pre><code>private class Student {\n    private String firstName;\n    private String lastName;\n\n    public Student(String firstName, String lastName) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n    }\n\n    public String getFirstName() {\n        return firstName;\n    }\n\n    public String getLastName() {\n        return lastName;\n    }\n}\n</code></pre> <p>Now we can create some students and store them in Redis as JSON:</p> <pre><code>final Gson gson = new Gson();\n\nStudent maya = new Student(\"Maya\", \"Jayavant\");\nclient.jsonSet(\"student:111\", gson.toJson(maya));\n\nStudent oliwia = new Student(\"Oliwia\", \"Jagoda\");\nclient.jsonSet(\"student:112\", gson.toJson(oliwia));\n</code></pre> <p>Some of other ways to store POJOs as JSON:</p> <pre><code>client.jsonSetLegacy(\"student:111\", maya);\nclient.jsonSetWithEscape(\"student:112\", oliwia);\n</code></pre>"},{"location":"redisjson/#querying-and-indexing-json","title":"Querying and indexing JSON","text":"<p>If we want to be able to query this JSON, we'll need to create an index. Let's create an index on the \"firstName\" and \"lastName\" fields.</p> <ol> <li>We define which fields to index (\"firstName\" and \"lastName\").</li> <li>We set up the index definition to recognize JSON and include only those documents whose key starts with \"student:\".</li> <li>Then we actually create the index, called \"student-index\", by calling <code>ftCreate()</code>.</li> </ol> <pre><code>Schema schema = new Schema().addTextField(\"$.firstName\", 1.0).addTextField(\"$.lastName\", 1.0);\n\nIndexDefinition rule = new IndexDefinition(IndexDefinition.Type.JSON)\n        .setPrefixes(new String[]{\"student:\"});\n\nclient.ftCreate(\"student-index\", IndexOptions.defaultOptions().setDefinition(rule), schema);\n</code></pre> <p>Alternatively creating the same index using FTCreateParams: </p> <pre><code>client.ftCreate(\"student-index\",\n        FTCreateParams.createParams().on(IndexDataType.JSON).prefix(\"student:\"),\n        TextField.of(\"$.firstName\"), TextField.of(\"$.lastName\"));\n</code></pre> <p>With an index now defined, we can query our JSON. Let's find all students whose name begins with \"maya\":</p> <pre><code>Query q = new Query(\"@\\\\$\\\\.firstName:maya*\");\nSearchResult mayaSearch = client.ftSearch(\"student-index\", q);\n</code></pre> <p>Same query can be done using FTSearchParams:</p> <pre><code>SearchResult mayaSearch = client.ftSearch(\"student-index\",\n        \"@\\\\$\\\\.firstName:maya*\",\n        FTSearchParams.searchParams());\n</code></pre> <p>We can then iterate over our search results:</p> <pre><code>List&lt;Document&gt; docs = mayaSearch.getDocuments();\nfor (Document doc : docs) {\n   System.out.println(doc);\n}\n</code></pre> <p>This example just scratches the surface. You can atomically manipulate JSON documents and query them in a variety of ways. See the RedisJSON docs, the RediSearch docs, and our course, \"Querying, Indexing, and Full-text Search in Redis\", for a lot more examples.</p>"}]}